#ifndef __HAND_HXX__
#define __HAND_HXX__

#include "Card.hxx"
#include <array>
#include <memory>
#include <boost/variant.hpp>

/* Used for ranking of different hand classes. */
typedef char ORDER_1[1];
typedef char ORDER_2[2];
typedef char ORDER_3[3];
typedef char ORDER_4[4];
typedef char ORDER_5[5];
typedef char ORDER_6[6];
typedef char ORDER_7[7];
typedef char ORDER_8[8];
typedef char ORDER_9[9];


class Hand
{
public:
  static const unsigned HAND_SIZE = 5;

  std::array<spc_type, 5> hand_;

  Hand()
  {
    int r = 0;
    int s = 1;

    for(int c = 0; c < HAND_SIZE; ++c)
    {
      hand_[c] = spc_type (new Card(Rank(r++), Suit(s)));
    }
  }

  bool operator < (Hand const& rhs)
  {
    return false;
  }

  bool operator == (Hand const& rhs)
  {
    return false;
  }

  ORDER_1& order();

};


/* **************************************************
   Pair Hand Class
   * **************************************************/
class Pair_Hand : public Hand
{
public:
  Rank pair_rank_;
  spc_type pair_card_1_;
  spc_type pair_card_2_;
  Rank high_card_;
  Rank second_high_card_;
  Rank third_high_card_;


  Pair_Hand(spc_type pc1, spc_type pc2, spc_type hc
	    , spc_type shc, spc_type thc)
    : pair_rank_(pc1->rank_), pair_card_1_(pc1), pair_card_2_(pc2)
    , high_card_(hc->rank_), second_high_card_(shc->rank_)
    , third_high_card_(thc->rank_)
  {
  }

  bool operator < (Pair_Hand const& rhs)
  {
    if(pair_rank_ < rhs.pair_rank_)
      return true;
    else if(pair_rank_ > rhs.pair_rank_)
      return false;
    else if(high_card_ < rhs.high_card_)
      return true;
    else if(high_card_ > rhs.high_card_)
      return false;
    else if(second_high_card_ < rhs.second_high_card_)
      return true;
    else if(second_high_card_ > rhs.second_high_card_)
      return true;
    else if(third_high_card_ < rhs.third_high_card_)
      return true;
    else
      return false;
  }

  bool operator == (Pair_Hand const& rhs)
  {
    return ( (pair_rank_ == rhs.pair_rank_) &&
	     (high_card_ == rhs.high_card_) &&
	     (second_high_card_ == rhs.second_high_card_) &&
	     (third_high_card_ == rhs.third_high_card_ ));

  }

  ORDER_2& order();
};


/* **************************************************
   Two Pair Hand Class
   * **************************************************/
class Two_Pair_Hand : public Hand
{
public:
  Rank high_pair_rank_;
  Rank low_pair_rank_;
  spc_type high_pair_card_1_;
  spc_type high_pair_card_2_;
  spc_type low_pair_card_1_;
  spc_type low_pair_card_2_;
  Rank high_card_;

  Two_Pair_Hand(spc_type hp1, spc_type hp2
		, spc_type lp1, spc_type lp2
		, spc_type hc)
    : high_pair_rank_(hp1->rank_), low_pair_rank_(lp1->rank_)
    , high_pair_card_1_(hp1), high_pair_card_2_(hp2)
    , low_pair_card_1_(lp1), low_pair_card_2_(lp2)
    , high_card_(hc->rank_)
  {
  }

  bool operator < (Two_Pair_Hand const& rhs)
  {
    if(high_pair_rank_ < rhs.high_pair_rank_)
      return true;
    else if (high_pair_rank_ > rhs.high_pair_rank_)
      return false;
    else
      if(low_pair_rank_ < rhs.low_pair_rank_)
	return true;
      else
	return false;
  }

  bool operator == (Two_Pair_Hand const& rhs)
  {
    return( (high_pair_rank_ == rhs.high_pair_rank_) &&
	    (low_pair_rank_ == rhs.low_pair_rank_) &&
	    (high_card_ == rhs.high_card_));
  }

  ORDER_3& order();
};

/* **************************************************
   Three of a Kind Hand Class
   * **************************************************/
class Three_Of_A_Kind_Hand : public Hand
{
public:
  Rank triple_rank_;
  spc_type triple_card_1_;
  spc_type triple_card_2_;
  spc_type triple_card_3_;
  Rank high_card_;
  Rank second_high_card_;

  Three_Of_A_Kind_Hand(spc_type tc1, spc_type tc2, spc_type tc3
		       , spc_type hc, spc_type shc)
    : triple_rank_(tc1->rank_), triple_card_1_(tc1)
    , triple_card_2_(tc2), triple_card_3_(tc3)
    , high_card_(hc->rank_), second_high_card_(shc->rank_)
  {
  }

  bool operator < (Three_Of_A_Kind_Hand const& rhs)
  {
    if(triple_rank_ < rhs.triple_rank_)
      return true;
    else if(triple_rank_ > rhs.triple_rank_)
      return false;
    else if(high_card_ < rhs.high_card_)
      return true;
    else if(high_card_ > rhs.high_card_)
      return false;
    else if(second_high_card_ < rhs.second_high_card_)
      return true;
    else
      return false;
  }

  bool operator == (Three_Of_A_Kind_Hand const& rhs)
  {
    return false;
  }
  ORDER_4& order();
};


/* **************************************************
   Straight Hand Class
   * **************************************************/
class Straight_Hand : virtual public Hand
{
public:
  Rank high_card_in_straight_;

  // Constructor for passing in the rank of high card in straight.
  Straight_Hand(Rank r)
    : high_card_in_straight_(r)
  {
  }

  // Constructor for passing in pointer to the high card.
  Straight_Hand(spc_type hc)
    : high_card_in_straight_(hc->rank_)
  {
  }

  virtual bool operator < (Straight_Hand const& rhs)
  {
    return high_card_in_straight_ < rhs.high_card_in_straight_;
  }

  virtual bool operator == (Straight_Hand const& rhs)
  {
    return high_card_in_straight_ == rhs.high_card_in_straight_;
  }

  virtual ORDER_5& order();
};

/* **************************************************
   Flush Hand Class
   * **************************************************/
class Flush_Hand : virtual public Hand
{
public:

  virtual bool operator < (Flush_Hand const& rhs)
  {
    return false;
  }

  virtual bool operator == (Flush_Hand const& rhs)
  {
    return false;
  }

  virtual ORDER_6& order();

};

/* **************************************************
   Full House Hand Class
   * **************************************************/
class Full_House_Hand : public Hand
{
public:
  Rank triple_rank_;
  Rank pair_rank_;

  // Constructor for passing in two ranks.
  Full_House_Hand(Rank tr, Rank pr)
    : triple_rank_(tr), pair_rank_(pr)
  {
  }

  // Constructor for passing in two shared pointers to cards.
  Full_House_Hand(spc_type tc, spc_type pc)
    : triple_rank_(tc->rank_), pair_rank_(pc->rank_)
  {
  }

  bool operator < (Full_House_Hand const& rhs)
  {
    if(triple_rank_ < rhs.triple_rank_)
      return true;
    else if(triple_rank_ > rhs.triple_rank_)
      return false;
    else
      if(pair_rank_ < rhs.pair_rank_)
	return true;
      else
	return false;
  }

  bool operator == (Full_House_Hand const& rhs)
  {
    return false;
  }

  ORDER_7& order();
};


/* **************************************************
   Four of a Kind Hand Class
   * **************************************************/
class Four_Of_A_Kind_Hand : public Hand
{
public:
  Rank quad_rank_;
  spc_type quad_card_1_;
  spc_type quad_card_2_;
  spc_type quad_card_3_;
  spc_type quad_card_4_;
  Rank high_card_;


  Four_Of_A_Kind_Hand(Rank r, spc_type qc1, spc_type qc2
		      , spc_type qc3, spc_type qc4, spc_type hc)
    : quad_rank_(r), quad_card_1_(qc1), quad_card_2_(qc2)
    , quad_card_3_(qc3), quad_card_4_(qc4)
    , high_card_(hc->rank_)
  {
  }

  bool operator < (Four_Of_A_Kind_Hand const& rhs)
  {
    return quad_rank_ < rhs.quad_rank_;
  }

  bool operator == (Four_Of_A_Kind_Hand const& rhs)
  {
    return false;
  }

  ORDER_8& order();
};



/* **************************************************
   Straight Flush Hand Class
   * **************************************************/

class Straight_Flush_Hand : public Straight_Hand, public Flush_Hand
{
public:

  bool operator < (Flush_Hand const& rhs)
  {
    return false;
  }

  bool operator == (Flush_Hand const& rhs)
  {
    return false;
  }

  ORDER_9& order();
};


/* **************************************************
   Ranked Hand using boost::variant
   * **************************************************/


typedef boost::variant
<
  Hand,
  Pair_Hand,
  Two_Pair_Hand,
  Three_Of_A_Kind_Hand,
  Straight_Hand,
  Flush_Hand,
  Full_House_Hand,
  Four_Of_A_Kind_Hand,
  Straight_Flush_Hand
  > Ranked_Hand;


struct Ranked_Hand_Less_Than
  : public boost::static_visitor<bool>
{
  template <typename T>
  bool operator () (T& t1, T& t2) const
  {
    return t1 < t2;
  }

  template <typename T, typename U>
  bool operator () (T& t, U& u) const
  {
    return (sizeof(t.order()) < sizeof(u.order()));
    //return true;
  }
};

struct Ranked_Hand_Equal_To
  : public boost::static_visitor<bool>
{
  template <typename T>
  bool operator () (T& t1, T& t2) const
  {
    return t1 == t2;
  }

  template <typename T, typename U>
  bool operator () (T& t, U& u) const
  {
    return false;
  }
};

bool operator < (Ranked_Hand const& lhs, Ranked_Hand const& rhs)
{
  return boost::apply_visitor(Ranked_Hand_Less_Than(), lhs, rhs);
}


bool operator == (Ranked_Hand const& lhs, Ranked_Hand const& rhs)
{
  return boost::apply_visitor(Ranked_Hand_Equal_To(), lhs, rhs);
}

// This works but I want to find out why it doesn't work with boost::variant.
bool compare(std::shared_ptr<Hand> lhs, std::shared_ptr<Hand> rhs)
{
  if(sizeof(lhs->order()) < sizeof(rhs->order()))
    return true;
  else if(sizeof(lhs->order()) == sizeof(rhs->order()))
    return lhs < rhs;
  else
    return false;
}

#endif
